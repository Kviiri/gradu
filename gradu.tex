% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[12pt,finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% spacing
\usepackage{setspace}
\onehalfspacing

% enumitem
\usepackage{enumitem}

% algorithm snippets
%\usepackage{algorithm}
% \usepackage{algpseudocode}
%\usepackage{caption}
%\floatname{algorithm}{Algoritmi}

% copy paste from http://tex.stackexchange.com/questions/33866/algorithm-tag-and-page-break
%\DeclareCaptionFormat{algor}{%
%  \hrulefill\par\offinterlineskip\vskip1pt%
%    \textbf{#1#2}#3\offinterlineskip\hrulefill}
%\DeclareCaptionStyle{algori}{singlelinecheck=off,format=algor,labelsep=space}
%\captionsetup[algorithm]{style=algori}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}

\newcommand*{\lcl}{\ensuremath{\mathsf{LCL}}}

\graphicspath{ {images/} }


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Verkko-ongelmien paikallisuus toroidihiloissa}
\author{Kalle Viiri}
\date{\today}
\level{Pro gradu -luonnos}
\abstract{Tähän tulee abstrakti.}

% The following can be used to specify keywords and classification of the paper:

\keywords{Hajautettu algoritmi, LOCAL}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
\classification{
\\\textbf{Computing methodologies---Randomized search}
\\\textit{Computing methodologies--Game tree search}
}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}
% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}
Hajautettu laskenta on laskennan teorian haara, joka tutkii laskentaongelmia verkoissa. Turingin koneista, RAM-koneista ja muista perinteisistä laskennan malleista poiketen hajautetulla algoritmilla ei ole keskitettyä tilaa tai muistia. Sen sijaan kukin solmu on oma laskentayksikkönsä muisteineen, ja suorittaa algoritmia itsenäisesti mutta toisten solmujen kanssa kommunikoiden, tavoitteena muodostaa koko verkon laajuinen ratkaisu käsillä olevaan laskentaongelmaan.

Hajautetun laskennan näkökulmasta voidaan tarkastella monenlaisia verkko-ongelmia. Eräs mielenkiintoinen ja helposti lähestyttävä ongelmien kategoria on paikallisesti tarkistettavien ongelmien joukko \lcl (locally checkable labeling). Verkko-ongelma on \lcl -ongelma, jos sen ratkaisun voi tarkastaa paikallisesti kunkin solmun ympäriltä vakiosäteisestä naapurustosta. Esimerkkejä \lcl -ongelmista ovat väritysongelmat ja maksimaalisen riippumattoman joukon etsiminen. Sen sijaan esimerkiksi Hamiltonin kierroksen etsiminen ei ole \lcl -ongelma, koska kukin solmu joutuu viestimään koko verkon halki varmistaakseen että kaikki solmut ovat varmasti osa samaa koko verkon läpi käyvää kierrosta. 

Hajautetun laskennan perusteiden tutkimista varten on helppoa tarkastella vain rajattua joukkoa verkkoja. Tämän vuoksi monet hajautettujen algoritmien ominaisuuksista ovat hyvin tunnettuja suunnatuille renkaille, eli 2-säännöllisille verkoille joilla on konsistentti kiertosuunta. Tässä opinnäytetyössä keskitytään vastaavasti suunnattuihin toroidihiloihin, eli vastaavasti 4-säännöllisiin verkkoihin joilla on kaksi konsistenttia kiertosuuntaa.

Hajautetun laskennan keskeinen haaste on minimoida tarpeeton kommunikaatio verkon solmujen välillä. Tämän vuoksi hajautetun algoritmin aikavaativuus ilmoitetaankin usein vain tarvittavien kommunikaatiokierrosten määrässä. Solmut eivät kuitenkaan tiedä verkon rakenteesta lähtökohtaisesti mitään oman välittömän naapurustonsa lisäksi, joten ongelmien ratkaiseminen vaatii vaikeimpien ongelmien tapauksessa kommunikaatiota jopa verkon kauimmaisten solmujen välillä.

Toroidihilojen tapauksessa \lcl -ongelmien aikavaativuuden tutkimukseen liittyy kaksi merkittävää tulosta. Ensimmäinen on nopeutuslemma, jonka avulla on osoitettu, että kunkin \lcl -ongelman aikavaativuus toroidihilassa on joko $\Theta(n)$, $\Theta(\log^* n)$ tai $\Theta(1)$ kommunikaatiokierrosta. Toinen merkittävä löydös on mahdottomuustulos, joka osoittaa, että \lcl -ongelman aikavaativuuden määrittäminen luokkien $\Theta(n)$ ja $\Theta(\log^* n)$ välillä on ratkeamaton ongelma. Sekä nopeutuslemma että mahdottomuustulos esitellään osana tätä opinnäytetyötä.

Mahdottomuustuloksesta huolimatta on olemassa prosessi, jonka avulla voimme muodostaa asymptoottisesti optimaalisia algoritmeja verkko-ongelmille joiden aikavaativuus on $O(\log^* n)$. Tämä algoritmisynteesiksi kutsuttu prosessi muodostaa verkon, jolle ongelman ratkaisusta voi johtaa algoritmin joka toimii kaikille hiloille. Menetelmä ei löydä algoritmia ongelmille, joiden aikavaativuus on $\Omega(n)$, ja mahdottomuustuloksen mukaisesti kaikkia tilanteita, joissa menetelmä etsii $O(\log^* n)$ -aikaista ratkaisua $\Omega(n)$ kommunikaatiokierrosta vaativalle pulmalle ei voi tunnistaa.

Algoritmisynteesi tarjoaa kuitenkin helpon tavan tunnistaa ja tutkia $O(\log^* n)$-aikaisia \lcl -ongelmia. Tämän opinnäytetyön laskennallinen osuus esittelee algoritmisynteesien tuloksia ja pyrkii niiden avulla muodostamaan havaintoja $O(\log^* n)$ kommunikaatiokierrosta vaativien ongelmien luonteesta.

\section{Määritelmät}
\subsection{Verkko}

%TODO määritelmäosuudessa on "jatkossa oletetaan" -kohtia. Käy ne läpi ja tarkasta että ovat yhä kurantteja

Suunnattu verkko on järjestetty pari $(V, E)$, missä $V$ on verkon solmujen joukko ja $E \subseteq (V \times V)$ on verkon kaarten joukko. $E$ on symmetrinen relaatio, ja kun $(v_1, v_2) \in E$ sanotaan verkossa olevan kaari solmujen $v_1$ ja $v_2$ välillä. Verkko ei voi sisältää kaarta solmusta itseensä, eli $(v, v) \notin E$ kaikille $v \in V$.

Kun $u, v \in V$ ja $(u, v) \in E$ kutsutaan solmuja $u$ ja $v$ toistensa naapureiksi. Solmun naapurien lukumäärää kutsutaan solmun asteeksi. Solmun $v$ astetta merkitään $deg(v)$.

Verkko on yhtenäinen, kun jokaisesta sen solmusta on olemassa verkon kaaria pitkin kulkeva reitti kuhunkin toiseen solmuun. Tässä työssä käsitellään vain yhtenäisiä verkkoja, eli jatkossa tarkoitamme verkoilla nimenomaisesti yhtenäisiä verkkoja.

Säännöllinen verkko on verkko, jonka kunkin solmun asteluku on sama. Verkkoa voidaan kutsua $n$-säännölliseksi, kun $\forall v \in V deg(v) = n$. Esimerkiksi $4$-säännöllinen verkko on verkko, jossa kunkin solmun asteluku on 4.

%TODO tämä kappale suunnatuista verkoista saattaa olla epärelevantti, koska on mahdollista että kaikki gradun suuntaukset onnistuvat paremmin kaarimerkintöjen kautta
Suunnattu verkko on järjestetty pari $(V, E)$, missä $V$ on verkon solmujen joukko ja $E \subseteq (V \times V)$ on verkon kaarten joukko. Toisin kuin suunnatussa verkossa, $E$ ei ole väistämättä symmetrinen relaatio. Kun $v_1, v_2 \in V$ ja $(v_1, v_2) \in E$ mutta $(v_2, v_1) \notin E$, kulkee $v_1$:stä yksisuuntainen kaari $v_2$:een. Tämä kaari ajatellaan kontekstista riippuen tarkoittamaan todellista yksisuuntaista yhteyttä, tai kaksisuuntaista mutta epäsymmetristä yhteyttä. Tämän opinnäytetyön piirissä käytetään vain jälkimmäistä merkitystä. Kun $(v_1, v_2) \in E$, sanotaan $v_1$:n olevan $v_2$:n edeltäjä ja $v_2$:n olevan $v_1$:n seuraaja.

Haluamme joskus sisällyttää kaariin enemmän informaatiota kuin pelkän suunnan kahden solmun välillä. Kutsumme tätä ylimääräistä informaatiota kaarimerkinnäksi (engl. \textit{edge labeling}). Verkon $G = (V, E)$ kaarimerkintä on funktio $\ell: E \rightarrow L$ missä $L$ on äärellinen joukko sallittuja kaarimerkkejä.

Kahta verkkoa, jotka ovat rakenteeltaan samanlaisia, kutsutaan keskenään isomorfisiksi. Formaalimmin verkot $G = (V, E)$ ja $G' = (V', E')$ ovat toistensa kanssa isomorfisia, kun on olemassa bijektio $f: V \rightarrow V'$ siten että $(u, v) \in E$ jos ja vain jos $(f(u), f(v)) \in E'$. Tällöin sanomme, että $f$ on isomorfismi $G$:n ja $G'$:n välillä. Kun $\ell$ ja $\ell'$ ovat vastaavasti $G$:n ja $G'$:n kaarimerkinnät, $f$ on lisäksi kaarimerkinnät säilyttävä isomorfismi kun $\ell((u, v)) = \ell'((f(u'), f(v')))$ kaikille $(u, v) \in E$ ja $(u', v') \in E'$.

%TODO :pidä huolta että määritelmät seuraavassa kappaleessa toimivat myös suunnatuille verkoille jos se tulee relevantiksi
Kahden solmun välinen etäisyys verkossa tarkoittaa kaarten lukumäärää lyhimmällä solmujen välisellä polulla. Kun verkko $G = (V, E)$, merkitsemme solmujen $u, v \in V$ välistä etäisyyttä $G$:ssä $dist_G(u, v)$. Tietyn solmun ja tietyn kaaren välinen etäisyys tarkoittaa lyhimmän tästä solmusta lähtevän kaaren kautta kulkevan polun pituutta. Kun $u \in V$ ja $e = (v, w) \in E$, merkitään $dist_G(u, e) = \text{min}\{dist_G(u, v), dist_G(u, w)\} + 1$.

Haluamme usein tutkia verkon osa-alueita, jonka solmut ovat korkeintaan tietyllä etäisyydellä jostakin keskipisteeksi valitusta solmusta. Kun $u \in V$ ja $r \in \mathbb{N}$, tarkoitetaan merkinnällä $B_G(u, r)$ $G$:n aliverkkoa joka sisältää kaikki solmut $v$ ja kaaret $e$ joilla $dist_G(u, v) \leq r$ ja $dist_G(u, e) \leq r$. Tätä aliverkkoa kutsutaan $u$:n naapurustoksi.

Verkon $n.$ potenssiverkko on verkko, johon on lisätty kaaria yhdistäen solmut joiden etäisyys on korkeintaan $n$ kaarta alkuperäisessä verkossa. Formaalimmin, kun $G = (V, E)$, sen potenssiverkko on $G^n = (V, E')$ siten että kun $u, v \in V$, $(u, v) \in E'$ jos ja vain jos $dist_G(u, v) \leq n$. Esimerkiksi $G^2$ sisältää kaikki $G$:n kaaret, ja lisäksi kaaria yhdistäen solmut joilla on $G$:ssä yhteinen naapuri.
\begin{figure}
  \includegraphics[width = \textwidth]{potenssiverkko.png}
  \caption{Vasemmalla on kuusisolmuinen rengasverkko $G$. Oikealla puolella on sen toinen potenssiverkko $G^2$, johon lisätyt kaaret on merkitty katkoviivalla.}
\end{figure}


%TODO :kuvia


%TODO :Verkko-ongelma?
%TODO :Puut sun muut
%TODO :Hajautetun algon käsite?
\subsubsection{Rengas ja hila}

Verkkoa kutsutaan renkaaksi, kun se on $2$-säännöllinen ja yhtenäinen. Kutsumme rengasta suunnatuksi renkaaksi, kun se on suunnattu verkko ja kullakin solmulla on tarkalleen yksi edeltäjä ja tarkalleen yksi seuraaja. Suunnatulla renkaalla on siis konsistentti kiertosuunta.

Kaksiulotteinen 4-hila, jatkossa vain hila, on 4-säännöllinen yhtenäinen verkko, jota voi pitää kaksiulotteisena yleistyksenä renkaasta. Hila on useasta samankokoisesta renkaasta kytketty ruudukko, joka on kytketty päistään yhteen synnyttäen toroidimaisen rakenteen. Hilan koko voidaan ilmoittaa ulottuvuuksina: $x \times y$ -kokoisessa hilassa on $y$ toisiinsa kytkettyä $x$ solmun rengasta. Oletamme yksinkertaisuuden vuoksi että $x = y$ kaikille hiloille.

Suunnatulla hilalla tarkoitamme hilaa jolla on suunnatun renkaan tavoin konsistentti kiertosuunta. Jokainen hilan sisältämä rengas kiertää samaan suuntaan, ja lisäksi kullakin solmulla on toinen seuraaja seuraavassa renkaassa ja toinen edeltäjä edellisessä renkaassa. Näin muodostuu ruudukko, jossa kullakin solmulla voidaan ajatella olevan seuraajat pohjoisessa ja idässä, ja vastaavasti edeltäjät etelässä ja lännessä.

Formaalimmin, suunnattu hila $G = (V, \mathsf{N}, \mathsf{E})$ on yleistys suunnatusta verkosta siten, että sillä on kahdentyyppisiä seuraajia ja edeltäjiä. Kullakin hilan solmulla $v \in V$ on koordinaatti siten että $v \in \{1, 2, \ldots, n\} \times \{1, 2, \ldots, n\}$. Määritellään solmun $v$ pohjoisnaapuri $\mathsf{S}: V \rightarrow V$ seuraavasti:
\[ \mathsf{N}(x, y) = 
  \begin{cases}
   (x, y+1) & \text{kun } y < n \\
   (x, 1) & \text{muuten}
  \end{cases}
\]

Määritellään vastaavasti $v$:n itänaapuri $\mathsf{E}: V \rightarrow V$:
\[ \mathsf{E}(x, y) = 
  \begin{cases}
   (x+1, y) & \text{kun } x < n \\
   (1, y) & \text{muuten}
  \end{cases}
\]

Yhdessä nämä funktiot muodostavat suunnatun hilan kaarten joukon $E$ = $\mathsf{N} \, \cup \, \mathsf{E}$. Määritellään vielä $v$:n etelänaapuri $\mathsf{S} = \mathsf{N}^{-1}$ ja länsinaapuri $\mathsf{W} = \mathsf{E}^{-1}$. Esimerkiksi $\mathsf{S}(v) = v'$ jos ja vain jos $\mathsf{N}(v') = v$. Vaikka hila muodostaa toroidimaisen rakenteen piirrämme hilat suorakulmion muotoisina siten, että hilan $x$-koordinaatti kasvaa oikealle ja $y$-koordinaatti ylöspäin.

Haluamme erottaa hilan solmujen pohjois-etelä -suuntaiset kaaret itä-länsi -suuntaisista. Tämän vuoksi määritellään kaarimerkintä $\ell: E \rightarrow \{\mathcal{N}, \mathcal{E}\}$ seuraavasti verkon kaarille $e \in E$:
\[ \ell(e) = 
  \begin{cases}
   \mathcal{N} & \text{kun } e \in \mathsf{N} \\
   \mathcal{E} & \text{muuten}
  \end{cases}
\]

Hiloista ja hilojen osista puhuessamme haluamme, että isomorfismit säilyttävät tämän kaarimerkinnän. Käytännössä tämä tarkoittaa sitä, että kukin solmu tietää nimenomaisesti kumpi sen seuraajista on pohjoisessa ja kumpi idässä.

\begin{figure}
  \centering
  \includegraphics{hilaesimerkki.png}
  \caption{Ylläolevassa kuvassa on $5 \times 5$ -kokoinen hila. Mustan solmun naapurit on merkitty $\mathsf{N}, \mathsf{E}, \mathsf{S}$ ja $\mathsf{W}$ vastaten solmun pohjois-, itä-, etelä- ja länsinaapuria. Hilalla ei ole varsinaisia reunoja, vaan se muodostaa toroidimaisen rakenteen. }
\end{figure}

%TODO :mitä käy jos solmu tietää koordinaattinsa ja hilan ulottuvuudet? (kaikki muuttuu O(1)-aikaiseksi)
%TODO :mitä käy jos solmu tietää koordinaattinsa muttei hilan ulottuvuuksia? (en tiedä lel)

\section{Aiempi työ}
%TODO :Naor&Stockmeyer? Suomela?

\section{Hajautettu algoritmi}

Hajautetussa laskennassa ratkaistaan verkko-ongelmia siten, että jokainen verkon solmu on oma laskentayksikkönsä ja verkon kaaret kuvaavat laskentayksiköiden välisiä kytkentöjä. Solmut eivät siis tunne koko verkon rakennetta, vaan ainoastaan oman välittömän ympäristönsä, mutta voivat laajentaa käsitystään ympäröivästä verkosta viestimällä naapuriensa kanssa.

Erilaisia hajautetun laskennan malleja on monia, mutta tässä työssä käytän Linialin~\cite{linial92} käyttämää LOCAL-mallia. LOCAL-mallissa kaikki solmut suorittavat samaa, determinististä algoritmia. Laskenta etenee synkronoiduissa kommunikaatiokierroksissa, joiden aikana kukin solmu voi lähettää mielivaltaisen määrän dataa naapureilleen, ja vastaavasti vastaanottaa kultakin naapuriltaan niiden lähettämän datan. Laskentakierrosten välissä kukin solmu voi suorittaa mielivaltaisen määrän laskentaa saamaansa dataa käyttäen.

%TODO rajaa tunnuksen ylärajaa
LOCAL-mallissa kullakin solmulla on tunnus, joka on yksilöllinen ei-negatiivinen kokonaisluku. Oletamme että, verkon $G = (V, E)$ ongelmaa ratkaisevalla algoritmilla on käytössään bijektio $\text{id}: V \rightarrow \mathbb{Z}_+$, joka määrittelee kunkin solmun tunnuksen. Kukin solmu tietää oman tunnuksensa algoritmin suorituksen aluksi, ja voi saada toisten solmujen tunnukset tietoonsa suorituksen aikana tapahtuvan kommunikaation perusteella. Hajautettua algoritmia voidaan pitää oikeellisena vain, jos sen tuottama tulos on oikeellinen riippumatta solmujen tunnuksista.

%TODO käytetäänkö input-funktiota missään?
Joissakin hajautetun laskennan ongelmissa solmut saavat myös syötettä sallittujen syötteiden joukosta $\Sigma$. Annettu syöte voi vaikuttaa algoritmin haluttuun tulokseen, tai olla esimerkiksi suoritusta nopeuttavaa neuvoa. Oletamme, että verkon $G = (V, E)$ ongelmaa ratkaisevalla algoritmilla on käytössään funktio $\text{input}: V \rightarrow \Sigma$, joka kertoo kunkin solmun syötteen. Kun $\Sigma$ jätetään määrittelemättä, oletamme sen sisältävän vain yhden alkion jolloin kukin solmu saa saman syötteen eikä voi mielekkäästi hyödyntää syötettä laskennassaan. Ellei toisin mainita, solmut eivät tiedä algoritmin suorituksen aluksi muuta kuin oman tunnuksensa ja syötteensä. Erityisen tärkeää on, etteivät hilojen solmut tunne koordinaattejaan tai hilan ulottuvuuksia.

Algoritmin suorituksen päätteeksi kukin solmu tulostaa oman osansa vastausta ongelmaan. Sallittujen tulosteiden joukko $\Gamma$ riippuu nimenomaisesta ongelmasta. Esimerkiksi verkon $k$-väritysongelmaa ratkaistaessa kukin solmu tulostaa arvon joukosta $\{1, 2, \ldots, k\}$ siten että mitkään kaksi toistensa naapurina olevaa solmua eivät tulosta samaa arvoa.

Ellei toisin mainita, edellytämme hajautetulta algoritmilta determinismiä. Tämä tarkoittaa, että tietyllä $\text{id}$ verkon $G = (V, E)$ kunkin solmun $v \in V$ saama tulosarvo riippuu ainoastaan solmun naapurustosta $B_G(v, r)$ missä $r$ riippuu algoritmin aikavaativuudesta, sekä naapuruston saamasta syötteestä. Voimme siis ajatella hajautettua algoritmia funktiona $f: (B_G(v, r), \text{id}, \text{input}) \rightarrow \Gamma$.


%TODO :Hajautetun algoritmin määritelmä
%TODO :Laskennan mallin määrittely.
%TODO :Syötteet ja tulosteet
%TODO :Paikallisen naapuruston määrittely
%TODO :Solmujen tunnisteet
\subsection{Järjestysinvariantti algoritmi}
Järjestystunnisteinen algoritmi (engl. \textit{order-invariant algorithm}) on hajautettu algoritmi, jossa solmut eivät käytä solmujensa todellisia arvoja vaan ainoastaan niiden keskinäistä järjestystä. Naor ja Stockmeyer osoittivat~\cite{naor95}, että varsinaisen tunnisteen vaihtaminen järjestystunnisteisuuteen ei rajoita algorimtin laskentavoimaa.

%TODO teoreemaformatointi
%TODO keskitetty verkko pitää määritellä

Naorin ja Stockmeyerin menetelmä muuttaa mielivaltaisia tunnisteita käyttävän hajautetun algoritmin $A$ järjestystunnisteiseksi algoritmiksi $A'$ seuraavasti: olkoon $L(K_1, s_1), ... , (K_z,s_z)$ keskitettyjä verkkoja syötteineen siten että solmujen tunnisteet on määritelty $A$:ssa. Olkoon $p$ suurin solmujen määrä missään verkossa $K_i$.

\section{Hajautettujen algoritmien aikavaativuus}
Toisin kuin perinteisessä laskennan vaativuusteoriassa, LOCAL-mallissa hajautetun algoritmin aikavaativuus ilmoitetaan algoritmin suoritukseen tarvittavien kommunikaatiokierrosten määrässä. Kukin solmu voi suorittaa toisilta solmuilta saamiensa tietojen perusteella mielivaltaisen paljon laskentaa. Tämän seurauksena kullekin ratkeavalle verkko-ongelmalle on olemassa algoritmi, jossa jokainen solmu välittää tietoaan verkon rakenteesta naapureilleen jotka välittävät niille kertynyttä tietoa eteenpäin, kunnes jokaisella solmulla on tiedossa koko verkon rakenne. Tällöin kukin solmu voi ratkaista verkko-ongelman sisäisesti ilman lisäkommunikaatiota. Tämän vuoksi verkko-ongelman aikavaativuus on aina $O(n)$, jos siihen on olemassa ratkaisu.

Muita verkko-ongelmille tyypillisiä aikavaativuusluokkia ovat vakioaikaisten algoritmien luokka $O(1)$ ja paikallisten algoritmien luokka $O(\log^*\ n)$, missä $\log^*$ tarkoittaa iteroitua logaritmia. Osoitamme myöhemmin, että kaikki verkko-ongelmat suunnatuille renkaille ja hiloille kuuluvat johonkin näistä kolmesta aikavaativuusluokasta tai ovat kokonaan ratkeamattomia.

Verkko-ongelman aikavaativuuden lisäksi meitä kiinnostaa usein tietää, milloin ongelman ratkaisuehdotuksen oikeellisuuden voi määritellä paikallisesti, eli tarkistamalla vain vakiosäteisen naapuruston kunkin solmun ympäristöstä~\cite{linial92}. Esimerkkejä tällaisista ongelmista ovat mm. verkon väritysongelmat, joiden ratkaisut ovat oikeellisia kun kunkin solmun $v$ naapureista kaikki saavat eri tulosteen kuin $v$.

Yllä kuvatun kaltaisia verkko-ongelmia, joissa ratkaisun oikeellisuuden voi tarkastaa vakioajassa, kutsutaan paikallisesti tarkastettavaksi merkinnäksi (engl. \textit{locally checkable labeling}, jatkossa \lcl). Naor ja Stockmeyer~\cite{naor95} määrittelevät \lcl-ongelman $\mathcal{L}$ formaalisti nelikkona $(r, \Sigma, \Gamma, \mathcal{C})$ missä $r \in \mathbb{Z}_+$ on paikallisuuden määrittävä säde, $\Sigma$ on äärellinen joukko mahdollisia syötearvoja solmuille, $\Gamma$ on äärellinen joukko mahdollisia tulostearvoja, ja $\mathcal{C} \subseteq \Sigma \times \Gamma$ on joukko $r$-säteisiä verkkoja, jotka ovat ongelman sallittuja osaratkaisuja.

%TODO ^ ohho, entäs jos \Sigma on tyhjä joukko? Tarkista C, se vaikuttaa epäilyttävältä.

Verkolle $G = (V, E)$ tehty merkintä $\lambda : V \rightarrow \Sigma \times \Gamma$ on LCL $\mathcal{L}$:n laillinen ratkaisu jos kaikille $u \in V$ on $u$:n $r$-säteinen naapurusto isomorfinen jonkin $\mathcal{C}$:n verkon kanssa.

\subsection{Tarkastussäde}
\lcl -ongelman sallitut ratkaisut ovat kaikki $r$-säteisiä verkkoja jollekin vakiolle $r$. Kutsumme $r$:ää ongelman tarkastussäteeksi, sillä se määrittää, kuinka suurta naapurustoa kunkin solmun ympäriltä on tarkasteltava jotta ongelman ratkaisu voidaan todeta oikeelliseksi.

Kun $P$ on \lcl -ongelma, jonka tarkastussäde on $r$, voimme muodostaa uuden \lcl -ongelman $P'$ joka vastaa $P$:tä siten, että $P'$:n tarkastussäde $r' = 1$. Lisäksi $P$:n ratkaisevan algoritmin tulosteesta voidaan muodostaa $P'$:n ratkaisu vakioajassa. Kukin $P'$:n tulostemerkki kuvaa mahdollista $r$-säteistä tulostemerkeillä merkittyä naapurustoa $P$:ssä. Jos meillä on $P$:n ratkaiseva algoritmi, voimme jalostaa siitä $P'$:n ratkaisevan algoritmin suorittamalla ensin $P$:n ratkaisualgoritmin ja käyttämällä $r$ kommunikaatiokierrosta kerätäksemme algoritmin tulokset $r$-säteisestä naapurustosta kuhunkin solmuun. Nyt $P'$:n ratkaisun voi tarkastaa vain sen välittömien naapurien perusteella.

Koska ongelman, jonka tarkastussäde on $r$, voi muuttaa vakioajassa vastaavaksi ongelmaksi jonka tarkastussäde on $1$, oletamme jatkossa kaikkien \lcl -ongelmien tarkistussäteen olevan $1$.

\subsection{Aikavaativuusluokat}
Monet hajautettujen verkko-ongelmien ominaisuudet tunnetaan hyvin rengasverkoissa. Sekä rengas- että hilaverkossa LCL-ongelman ratkaisemisen aikavaativuus on aina $\Theta(1)$, $\Theta (\log^* n)$ tai $\Theta(n)$, jos se on ylipäänsä ratkaistavissa. Mielivaltaisissa verkoissa \lcl -ongelmalla voi olla myös muita aikavaativuuksia kuten $\Theta(\log n)$.

\subsubsection{Vakioaikaiset ongelmat}
%TODO ymmärrä allaoleva ja korjaa se jos se on rikki

Hilan syötteettömään \lcl -ongelmaan $P$ on $O(1)$ -aikainen ratkaisu jos ja vain jos ongelman määrittely sallii koko verkon täyttämisen samalla tulostemerkillä $\gamma \in \Gamma$~\cite{chang}. Muuten aikavaativuus on $\Omega(\log^* n)$.

Olkoon $G = (V, E)$ hila, jonka ulottuvuudet ovat $n \times n$. Kukin hilan solmu $v \in V$ saakoon koordinaatit $(x, y)$ siten että $x, y \in {0, 1, \dots, n-1}$. Käytämme näitä funktioita yhdessä kunkin solmun $k \log n$ -bittisenä tunnisteena. Olkoot $\phi_x$ ja $\phi_y$ funktioita joukosta $\{0, 1,\dots, n-1\}$ joukkoon $\{0, 1,\dots,n^k-1\}$ joille pätee $\phi_x(0) < \phi_x(1) < \dots < \phi_x(n-1) < \phi_y(0) < \phi_y(1) < \dots < \phi_y(n-1)$. Sijainnissa $(x, y)$ sijaitsevan solmun tunnus on $\phi_x(x) \cdot n^{k/2} + \phi_y(y)$.

Tarkastellaan solmua $v = (x, y)$ ja sen naapurustoa $B_G(v, \tau)$. Kaikki naapuruston tunnukset voi päätellä tuntemalla $\phi_x(x)$:n ja $\phi_y(y)$:n, sekä $v$:stä suoraan pohjoiseen ja etelään sekä itään ja länteen kuuluvien solmujen $i$ tunnisteet $\phi_x(i)$ kun $x - \tau \leq i \leq x + \tau$ ja $\phi_y(j)$ kun $y - \tau \leq j \leq y + \tau$. Nämä $4\tau + 2$ arvoa määrittävät yksiselitteisesti koko $B_G(v, \tau)$:n tunnistearvot.

Oletetaan että $P$ on ratkaistavissa $o(\log^* n)$ kommunikaatiokierroksessa. Olkoon $A$ algoritmi joka ratkaisee $P$:n $\tau$ kommunikaatiokierroksessa. $A$:n oikeellisuus ei voi riippua tunnisteiden valinnasta, joten $\phi_x$:n ja $\phi_y$:n muodostamat tunnisteet kelpaavat sille ja $A$ muodostaa oikeellisen lopputuloksen.

Olkoon $S = (s_1, s_2,\dots,s_{4\tau+2})$ vektori joukosta $\{0, 1,\dots,n^k - 1\}$ siten että $s_k < s_{k+1}$ kaikille $k \in [0, 4\tau + 2]$. Muodostamme $A$:n perusteella funktion $f: S \rightarrow \Gamma$, ja kuvaamme sillä arvoa jonka solmu $v$ tulostaa kun sen $\tau$-säteinen naapurusto vastaa tiettyä $S$:n alkiota $A$:ta suorittaessa.

Olkoon $\phi_x(x - \tau - 1 + i) = s_i$ kullekin $i \in [0, 2\tau + 1]$ ja $\phi_y(y - \tau - 1 + j) = s_{j+2\tau+1}$ kullekin $j \in [0, 2\tau + 1]$. Olkoon $c = |\Sigma|$ ja $p = 4\tau + 2$ ja $m = 4\tau + 4r + 2$ missä $r$ on $P$:n tarkastussäde. Ramseyn teoreemasta saadaan $R(p, m, c) << n^2$. On olemassa joukko $S'$ siten että $|S'| = m$ joukosta $\{0, 1,\dots,n^k\}$ jotka voidaan asettaa $\phi_x(i)$:n ja $\phi_y(j)$:n arvoiksi kun $i \in [x - \tau - r, x + \tau + r]$ ja $j \in [y - \tau - r, y + \tau + r]$ siten että $\phi_x(x - \tau - r) < \dots < \phi_x(x + \tau + r) < \phi_y(y - \tau - r) < \dots < \phi_y(y + \tau + r)$.

Kun olemme määrittäneet $\phi_x$:n ja $\phi_y$:n näin, $A$ asettaa kaikkiin naapuruston $B_G(v, \tau)$ solmuihin saman arvon $\gamma \in \Gamma$. Täten ratkaisu, jossa verkon jokainen solmu valitsee tulosteen $\gamma$ on $P$:n oikeellinen ratkaisu. Selvästi nähdään, että ongelman voi ratkaista $O(1)$ kommunikaatiokierroksessa algoritmilla, joka vain tulostaa $\gamma$:n.

\subsubsection{Nopeutuslemma ja normaalimuoto}

%TODO tarkista nopeutuslemman oikeellisuus

Nopeutuslemma on menetelmä, jonka avulla voimme muodostaa $\Theta(\log^* n)$-aikaisen algoritmin \lcl -ongelmalle, johon tunnetaan $o(n)$-aikainen algoritmi. Tämä tarkoittaa, että ongelman aikavaativuus ei voi olla asymptoottisesti aidosti luokkien $\Theta(\log^* n)$ ja $\Theta(n)$ välissä, sillä jos ongelmalle on algoritmi jonka aikavaativuus on tuossa välissä, nopeutuslemman avulla sen ratkaisemiseksi on muodostettavissa myös $\Theta(\log^* n)$-aikainen algoritmi.

Oletetaan, että \lcl -ongelmaan $L$ on algoritmi $A$ joka tuottaa ratkaisun ajassa $T(n) = o(n)$. Nopeutuslemman avulla muodostamme $A$:n perusteella $\Theta(\log^* n)$ -aikaisen algoritmin joka ratkaisee saman ongelman.

Nopeutuslemma perustuu hilan jakamiseen pienempiin $k \times k$ -kokoisiin osiin ja ongelman ratkaisemiseen kullekin osalle itsenäisesti. Valitaan pienin $k \geq 4$ siten että $T(k) < k/4 - 4$. Tällainen $k$ on pakko olla olemassa oletuksemme $T(n) = o(n)$ johdosta. $k$ on ainoastaan $T$:stä riippuva vakio.

Haluamme jakaa verkon solmuille uudet paikallisesti yksilöivät tunnukset joukosta $\{1, 2, 3, \ldots, k^2\}$ siten, että kussakin $k \times k$ -ruudussa esiintyy kukin tunnus tarkalleen kerran. Tämä tehdään etsimällä maksimaalinen riippumaton joukko $I$ potenssiverkosta $G^{(k/2)}$, mikä on mahdollista suorittaa ajassa $O(log* n)$. Koska $I$ on maksimaalinen riippumaton joukko $G^{(k/2)}$:ssa, kukin $G$:n solmu on korkeintaan $k/2$ kaaren päässä lähimmästä $I$:n solmusta. Kun $v$ on $G$:n solmu, kutsumme sitä lähinnä olevaa $I$:n solmua $v$:n ankkuriksi ja merkitsemme sitä $a(v)$. Kahden tai useamman $I$:n solmun ollessa yhtä lähellä voi $v$ valita ankkurinsa niiden keskuudesta mielivaltaisesti.

Koska kukin solmu on korkeintaan $k/2$ kaaren päässä ankkuristaan ja $k$ on vakio, voi kukin solmu selvittää ankkurinsa sekä sijaintinsa suhteessa siihen vakioajassa. Kunkin solmun $v$ suhteellinen sijainti $c(v) = (x_v - x_{a(v)}, y_v - y_{a(v)})$ toimii $v$:n paikallisesti yksilöivänä tunnuksena. Koordinaatti on paikallisesti yksilöivä, sillä $I$:n solmut ovat väistämättä yli $k/2$ kaaren etäisyydellä toisistaan. Jos kaksi eri solmua $u$ ja $v$ saavat saman koordinaatin, niiden on vastaavasti oltava vähintään $k/2$ etäisyydellä toisistaan.

Kun koordinaatteja ankkurin suhteen käytetään paikallisesti yksilöivänä tunnuksena, missään $k \times k$ -ruudussa ei esiinny samaa paikallista tunnusta kahdesti tai useammin. Nyt käytämme $A$:ta verkko-ongelman ratkaisuun $G$:ssä pienellä muutoksella: kerromme $A$:lle ratkaistavan hilan ulottuvuuksien olevan $k \times k$. Nyt $A$ ratkaisee hilan ongelman vakioajassa. Ratkaisun on oltava oikeellinen, sillä $A$:n näkökulmasta sen näkemä $k \times k$ -hila on täysin normaali ongelman instanssi.

Koska $k$ riippuu vain ongelman $L$ aikavaativuudesta, se on ongelmakohtaisesti vakio. Täten algoritmin $A$ suorittaminen $k \times k$ -kokoisen hilan kappaleella on aikavaativuudeltaan $O(1)$. Koska nopeutuslemmalla muodostettava algoritmi joutuu laskemaan verkon $G^k$ maksimaalisen riippumattoman joukon, aikavaativuus on $\Theta(\log^* n)$.

\subsection{Esimerkkejä ongelmista}
%TODO tämä pitänee siirtää ennen nopeutuslemmaa, sekä esitietojen että järkevyyden nimissä
\subsubsection{Verkon väritysongelma}
Verkon väritysongelmana on tarkoitus löytää verkolle $G = (V, E)$ kuvaus $c : V \rightarrow C$ siten että millekään $v \in V$ ei ole olemassa $u \in B_G(v, 1), u \neq v$ jolle $c(u) = c(v)$. Kun $|C| = n$, kutsumme $c$:tä verkon $n$-väritykseksi. Kun $v \in V$, arvoa $c(v)$ kutsutaan solmun $v$ väriksi.

Verkon värityksen oikeellisuus riippuu vain kunkin solmun välittömästä naapurustosta, joten kyseessä on \lcl -ongelma. Kukin solmu $v$ voi tarkistaa värityksen oikeellisuuden lähiympäristössään vastaanottamalla tiedon kaikkien naapuriensa väreistä ja vertaamalla niitä omaan väriinsä. Väritys on oikeellinen jos yhdelläkään solmun $v$ naapurilla ei ole väriä $c(v)$.

Esittelen menetelmän, jolla voidaan muodostaa hilalle tai hilan potenssiverkolle $k$-väritys hilan koosta riippumattomalle vakiolle $k$. Menetelmä perustuu Cole-Vishkin -algoritmiin, joka on tarkoitettu suunnattujen puiden värittämiseen, mutta josta voi johtaa ratkaisuja muihinkin väritysongelmiin.

Verkko $G = (V, E)$ on suunnattu puu, kun sillä on juuri $r \in V$ siten, että kustakin solmusta $v \in (V \setminus r)$ on tarkalleen yksi reitti juureen ja kukin kaari on suunnattu osoittamaan juureen. Kun $v, u \in V$ ja $(u, v) \in E$, sanomme $v$:n olevan $u$:n vanhempi ja $u$:n olevan $v$:n lapsi. Merkitsemme solmun $v \neq r$ vanhempaa $\pi_v$. 

Cole-Vishkin -algoritmi alustaa kunkin $v \in V$ värin siten että $c(v) = \text{id}(v)$, ja suorittaa sen jälkeen $O(log^* n)$ iteratiivista kierrosta joista kukin vähentää värien määrää kunnes jäljellä on vain kuusi väriä.

Merkitköön $c(u)[i]$ solmun $u$ värin $i.$ merkitsevintä bittiä. Kukin solmu $u \neq r$ vastaanottaa kullakin kierroksella vanhempansa värin $c(\pi_u)$, ja asettaa uudeksi värikseen $c'(u) = \langle i, c(\pi_u)[i] \rangle$ pienimmälle $i$:n arvolle jolle $c(u)[i] \neq c(\pi_u)[i]$. Juuri $r$ asettaa värikseen $c'(r) = \langle i, c(r)[i] \rangle$ mielivaltaiselle indeksille $i$. 

Tarkastellaan väritystä $c'$ mielivaltaisen solmun $u$ näkökulmasta olettaen, että $c'$ muodostettiin oikeellisen värityksen $c$ pohjalta. Merkitään $i(c'(u))$ ja $i(c'(\pi_u))$ solmujen $u$ ja $\pi_u$ uusien värien $i$-osuutta. Jos $i(c'(u)) \neq i(c'(\pi_u))$, väritys on oikeellinen. Muussa tapauksessa olkoon $i = i(c'(u))$. Värityksen määritelmän mukaan $c(u)[i] \neq c(\pi_u)[i]$, jolloin $c'(u) \neq c'(\pi_u)$ toisen kentän bitissä. Uusi väritys on siis selvästi oikeellinen.

Olkoon $N_0 = \lceil{\log n}\rceil$ alkuperäisen värityksen tarvitsema bittien enimmäismäärä solmulle $v \in V$, ja $N_j$ tarvittavien bittien enimmäismäärä $j$ kommunikaatiokierroksen jälkeen. Koska $i$ on korkeintaan solmun värin vanhempien bittien määrä ja uudessa värityksessä on sen lisäksi yksi bitti, $N_{j+1} \leq \lceil \log N_j \rceil + 1 \leq \lceil \log N_j \rceil + 2$.

Jatkamalla tästä huomaamme että $N_1 \leq N_0 + 2$, ja $N_2 \leq \log (\log N_0 + 2) \leq \log^2 N_0 + 3$ jos $N_0 \geq 2$. Huomaamme että kun $j = 1, 2, \ldots$ ja $\log^{(j)} N_0 \geq 3$, jolloin $N_j < \log^{(j)} N_0 + 3$.
%TODO jatka ylle

Algoritmi vähentää värien määrän kuuteen. Binääriesityksen pituus on tällöin kolme bittiä, mutta värin ensimmäinen kenttä voi olla vain $01$, $10$ tai $11$. Viimeinen bitti voi olla $0$ tai $1$ jolloin eri värejä on käytössä kuusi.

Cole-Vishkin -algoritmin avulla on mahdollista määrittää väritys myös hilalle. Kukin solmu $u$ suorittaa algoritmia kahdelle eri puulle samaan aikaan: yhdessä sen vanhempana on $\mathsf{N}(u)$ ja toisessa $\mathsf{E}(u)$. Tällöin solmun $u$ väri on $c(u) = \langle c_\mathcal{N}(u), c_\mathcal{E}(u) \rangle$, missä $c_\mathcal{N}(u)$ on solmun $u$ väri etelä-pohjoissuuntaan toimivan algoritmin antamana ja vastaavasti $c_\mathcal{E}(u)$ on sen väri länsi-itä -suuntaan toimivan algoritmin mukaan. Koska värin $c(u)$ ensimmäinen kenttä on eri värin $c(\mathsf{N}(u))$ ensimmäisen kentän kanssa ja toinen kenttä on eri värin $c(\mathsf{E}(u))$ kanssa, värityksen on oltava oikeellinen.

Samankaltaista menetelmää voi käyttää myös hilan potenssiverkkojen värittämiseksi $O(\log^* n)$ kommunikaatiokierroksessa. Esimerkiksi hilan toista potenssia värittäessä kunkin solmun $u \in V$ väri $c(u)$ koostuu kuudesta kentästä. Samoin kuin aiemmin $c_\mathcal{N}(u)$ ja $c_\mathcal{E}(u)$ ovat solmun värityksiä normaalissa etelä-pohjois- ja länsi-itä -suuntaisina. Tämän lisäksi väritykseen kuuluvat kaakko-lounais -suuntainen väritys $c_\mathcal{(N,E)}(u)$ ja luode-koillis -suuntainen väritys $c_\mathcal{(S,E)}(u)$, sekä kaksi kaarta kerrallaan etelä-pohjois -suunnassa kulkeva väritys $c_\mathcal{(N,N)}(u)$ ja kaksi kaarta kerrallaan länsi-itä -suunnassa kulkeva väritys $c_\mathcal{(E,E)}(u)$.

Väite: kun hilan $G$ potenssiverkon $G^2 = (V, E^2)$ värityksen $c(u)$ osat ovat oikeellisia värityksiä kullekin $u \in V$, $c$ itsessään on oikea väritys. Todistus: valitaan mielivaltainen kaari $(v, w) \in E^2$. Merkitään kaaren suuntaa $\mathsf{D} \in \{  \mathsf{N, E, NE, SE, NN, EE}\}$. Olkoon $\mathsf{D}$ värityksen $j.$ kenttä, ja $i_v$ sekä $i_w$ tuohon kenttään valittu indeksi. Jotta $c(v) = c(w)$ olisi pakko päteä $i_v = i_w$, jolloin Cole-Vishkin -algoritmi asettaa kenttään väistämättä eri bittiosuuden.

\subsubsection{Maksimaalinen riippumaton joukko}
Kun $G = (V, E)$, joukko $I \subset V$ on riippumaton joukko kun kaikilla $u, v \in I$ pätee $(u, v) \notin E$ ja $(v, u) \notin E$. Riippumaton joukko on maksimaalinen, kun lisäksi ei ole olemassa $I' \supsetneq I$ joka olisi myös riippumaton joukko. Toisin sanoen riippumaton joukko $I$ on maksimaalinen jos ja vain jos $I \cup \{w\}$ ei ole riippumaton joukko millekään $w \in V \setminus I$.

Maksimaalisen riippumaton joukon voi määrittää myös \lcl -ongelmana. Määritellään $\Gamma = {1, 0}$ siten, että vain solmut jotka tulostavat $1$ kuuluvat maksimaaliseen riippumattomaan joukkoon. Riippumattomuus toteutuu, kun kullakin $1$-merkkisellä solmulla on vain $0$-merkkisiä naapureita. Maksimaalisuus toteutuu, kun kullakin $0$-merkkisellä naapurilla on vähintään yksi $1$-merkkinen naapuri. Sallittujen osittaisratkaisujen joukko näyttää siis seuraavalta:
%TODO kuva

Voimme antaa verkolle syötteeksi joukon solmuja, ja tarkistaa $O(1)$-ajassa onko joukko riippumaton. Jokainen solmu käyttää yhden kommunikaatiokierroksen lähettääkseen syötteensä naapureille. Nyt kukin solmu voi tarkistaa tuloksen oikeellisuuden vertailemalla naapuriensa syötteitä omiinsa, eli kyseessä on \lcl -ongelma.

Linial osoitti~\cite{linial92} alarajan, jonka mukaan maksimaalisen riippumattoman joukon laskeminen on aikavaativuudeltaan $\Omega(log^* n)$ mielivaltaiselle verkolle. Hiloille on olemassa $O(log^* n)$ -aikainen algoritmi, joka voidaan johtaa alunperin suunnattujen puiden värittämiseen tarkoitetusta Cole-Vishkin -algoritmista.

Kun verkolle on $k$-väritys jollekin vakiolle $k$, voidaan sen perusteella muodostaa maksimaalinen riippumaton joukko ajassa $O(1)$. Merkitsemme solmun $v \in V$ saamaa väriä $c(v)$. Koska kyseessä on $k$-väritys, $c(v) \in \{1, 2, \ldots, k\}$. Värityksen ehdon mukaisesti $c(v) \neq c(u)$ kaikille $u \in B_G(v, 1) \setminus {v}$.

Rakennamme värityksen perusteella maksimaalisen riippumattoman joukon iteratiivisesti. Olkoon $I_1 = \{ v \in V : c(v) = 1 \}$. Koska millään kahdella naapurilla ei ole samaa väriä, selvästi $I_1$ on riippumaton joukko. Muodostetaan kullakin laskenta-askeleella uusi joukko

$$I_{n+1} = I_n \cup \{ v \in V : (c(v) = n+1) \land \nexists u \in I_n (v \in B_G(u, 1)) \}$$

joka ei sisällä yhtään solmua joukon $I_n$ naapurustosta ja on siten yhä riippumaton. Nähdään, että $I_1 \subseteq I_2 \subseteq \ldots \subseteq I_k$.

Väite: riippumaton joukko $I_k$ on maksimaalinen. Todistus: Olkoon $v \in V$ mielivaltainen verkon solmu. Jos $I_{c(v)-1} \cap B_G(v, 1) = \emptyset$, iteraation määritelmän mukaan $v \in I_{c(v)}$. Näin ollen $\exists u \in B_G(v, 1) (u \in I_k)$, eli $I_k$ on oltava maksimaalinen.


%Allaoleva on deletoitavaa kun saat sen CV algon esiteltyä
Esittelen seuraavaksi Schneiderin ja Wattenhoferin algoritmin, joka laskee maksimaalisen riippumattoman joukon $O(log^* n)$ -ajassa, eli on asymptoottisesti optimaalinen.
%TODO algoritmi toimii vain Bounded Growth -verkoille

Schneiderin ja Wattenhoferin algoritmissa jokainen verkon solmu on aluksi kandidaatti kuulumaan maksimaaliseen riippumattomaan joukkoon. Solmuja eliminoidaan "kilpailuissa" kunnes lopulta jäljellä on vain maksimaalinen riippumaton joukko. 
%TODO citet ylle

Ensimmäisellä kierroksella kunkin solmun pistearvo on sen tunniste. Kukin solmu $v$ haastaa naapurustonsa solmun $u$, jonka tunniste on $v$ itse pois lukien kaikista pienin. Jos $\text{id}(v) < \text{id}(u)$, $v$ saa pistearvokseen kierrokselta $0$. Muussa tapauksessa $v$ saa uuden pistearvon, joka on eniten merkitsevä bitti $\text{id}(v)$:n binääriesityksessä jonka arvo on $1$ kun samassa paikassa oleva $\text{id}(u)$:n bitti on $0$.

Kun solmun pistearvo on pienempi kuin yhdelläkään sen naapureista, se otetaan osaksi maksimaalista riippumatonta joukkoa ja se lopettaa kilpailun. Solmun naapurit ovat tällöin dominoituja eivätkä myöskään osallistu tuleviin kilpailuihin. Solmut, jotka ovat pistearvoltaan korkeintaan yhtäsuuria kuin kaikki naapurinsa ja yhtäsuuria vähintään yhden kanssa asetetaan tauolle eivätkä ne osallistu kilpailuihin.
%TODO tarkasta ylläoleva


 
\iffalse
\subsubsection{Heikko väritysongelma}
Heikossa $c$-väritysongelmassa on tarkoituksena löytää annetun verkon $G = (V, E)$ kullekin solmulle merkki joukosta $\{1, 2, ..., c\}$ siten että kaikilla $v \in V$, ainakin yksi $v$:n naapureista saa eri merkin kuin $v$ paitsi jos $v$:llä ei ole naapureita. Koska ratkaisun oikeellisuuden voi tarkistaa yksittäisten solmujen välittömästä naapurustosta, kyseessä on \lcl -ongelma. Naor ja Stockmeyer~\cite{naor95} osoittivat, että heikko väritysongelma on mahdollista ratkaista vakioajassa, jos kunkin solmun aste on pariton.

Kullekin yhtenäiselle verkolle on olemassa heikko 2-väritys, jonka voi löytää muodostamalla leveyssuuntaisesti verkon virityspuun~\cite{naor95}. Juuresta alkaen parilliset solmut saavat värin 1 ja parittomat värin 2. Kaikki solmut kattavaa puuta ei kuitenkaan voi muodostaa paikallisesti, joten hajautetun algoritmin täytyy lähestyä ongelmaa eri tavalla.

Naor ja Stockmeyer~\cite{naor95} osoittivat, että verkoille, joiden jokaisen solmun aste on pariton ja suurin asteluku on $d$, on mahdollista löytää heikko 2-väritys paikallisesti. Väritys löydetään muodostamalla ensin heikko $d(d + 1)^{d+2}$ -väritys kahdella laskenta-askeleella, ja karsimalla se sitten 2-väritykseksi.

Olkoon verkko $G$ on $d$-säännöllinen siten, että $d$ on pariton ja $d \geq 3$. Solmun $v$ saama väri $C_v$ on $d+1$ -paikkainen vektori, jonka kukin arvo kuuluu joukkoon $\{1, 2, ..., d+1\}$. Ensimmäisellä laskenta-askeleella kukin solmu lähettää tunnistelukunsa naapureilleen. Tämän perusteella kukin solmu pystyy määrittämään naapureillensa järjestysluvun (engl. \textit{rank}). Merkitään solmun $w$ tunnuksen järjestyslukua $v$:n naapurustosta $r_v(w)$. Naapuruston pienimmän tunnuksen järjestysluku on 1, toisiksi pienimmän 2 ja niin edelleen.

Kukin solmu $v$ asettaa värivektorinsa ensimmäiseksi arvoksi oman järjestyslukunsa $r_v(v)$. Seuraavalla laskenta-askeleella kukin $v$ saa jokaiselta naapuriltaan $r_w(v)$:n, eli tiedon mikä järjestysluku niillä on naapuriensa naapurustossa. Asetetaan $C_v[r_v(w)] = r_w(v)$. Nyt väritys on valmis.
\fi

%TODO : Parillisten solmujen versio


\subsection{Aikavaativuuden määrittämisen ratkeamattomuus}
Yleisessä tapauksessa \lcl -ongelman aikavaativuuden määrittäminen $\Theta(log^* n)$ ja $\Theta(n)$ välillä on Turing-ratkeamaton ongelma. Brandt ym.~\cite{brandt} osoittavat tämän määrittelemällä kullekin Turingin koneelle $M$ vastaavan \lcl -ongelman $L_M$ siten, että $M$ pysähtyy äärellisessä ajassa jos ja vain jos $L_M$ on ratkaistavissa $\Theta(log^* n)$-ajassa ja vastaavasti ei pysähdy jos $L_M$ ratkeaa vain $\Theta(n)$-ajassa. Tällöin $L_M$:n aikavaativuuden määrittäminen mahdollistaisi $M$:n pysähtymistarkastamisen, joka tiedetään pysähtymisongelman nojalla mahdottomaksi.

%TODO : cite

Brandt ym. rakentavat $L_M$:n siten, että $L_M$ on unioni kahdesta \lcl -ongelmasta $P_1$ ja $P_2$. Tällä tarkoitetaan, että $L_M$:n ratkaisu on oikeellinen jos se on joko $P_1$:n tai $P_2$:n oikeellinen ratkaisu. $P_1$ on $M$:stä riippumatta hilan 3-värityksen etsiminen, johon on aina ratkaisu, mutta jonka ratkaisun löytäminen vaatii $\Omega(n)$ kommunikaatiokierrosta. $P_2$ puolestaan on hilan jakaminen ruutuihin, joista kuhunkin tulostetaan $M$:n suoritushistoria. $P_2$, ja siten $L_M$, ratkeaa $\Theta(log^* n)$ kommunikaatiokierroksessa jos ja vain jos $M$ pysähtyy tyhjällä nauhalla käynnistäessä.

$P_2$:n oikeellisessa ratkaisussa kullekin solmulle määritellään tyyppi. Solmut voivat olla reunoja, jolloin niiden tyyppi on joukosta $\{\mathsf{N, E, S, W}\}$, kvadrantteja, jolloin niiden tyyppi on joukosta $\{\mathsf{NE, SE, SW, NW}\}$, tai ankkureita, joiden tyyppi on $A$. Merkitsemme solmun $v$ tyyppiä $Q(v)$. Kutsumme muun kuin ankkurisolmun diagonaalinaapuriksi solmua, johon pääsee kulkemalla solmun tyypin merkitsemään suuntaan seuraavin lisäyksin normaaliin hilanotaatioomme:
\begin{itemize}[label={}]
  \item $\mathsf{NE}(v) = \mathsf{N}(\mathsf{E}(v))$,
  \item $\mathsf{SE}(v) = \mathsf{S}(\mathsf{E}(v))$,
  \item $\mathsf{NW}(v) = \mathsf{N}(\mathsf{W}(v))$,
  \item $\mathsf{SW}(v) = \mathsf{S}(\mathsf{W}(v))$.
\end{itemize}
Ankkurisolmu on itsensä diagonaalinaapuri. Merkitsemme solmun $v$ diagonaalinaapuria $diag(v)$. Esimerkiksi jos $Q(v) = \mathsf{SE}$, $diag(v) = \mathsf{SE}(v)$. $P_2$:n oikeellisessa ratkaisussa kaikkien solmujen diagonaalinaapureita seuraamalla on päädyttävä ankkurisolmuun.

Haluamme kvadranttien olevan seuraavalla tavalla yhdenmukaisia:
\begin{itemize}[label={}]
  \item kun $Q(v) = \mathsf{NE}$ niin $Q(diag(v)) \in \{\mathsf{NE}, \mathsf{N}, \mathsf{E}, \mathsf{A}\}$,
  \item kun $Q(v) = \mathsf{SE}$ niin $Q(diag(v)) \in \{\mathsf{SE}, \mathsf{S}, \mathsf{E}, \mathsf{A}\}$,
  \item kun $Q(v) = \mathsf{SW}$ niin $Q(diag(v)) \in \{\mathsf{SW}, \mathsf{S}, \mathsf{W}, \mathsf{A}\}$, sekä
  \item kun $Q(v) = \mathsf{NW}$ niin $Q(diag(v)) \in \{\mathsf{NW}, \mathsf{N}, \mathsf{W}, \mathsf{A}\}$.
\end{itemize}
Kvadranttien välisillä reunoilla $P_2$:n ehtoihin kuuluu, että joko $Q(diag(v)) = Q(v)$ tai $Q(diag(v)) = \mathsf{A}$. Lisäksi määritellään, että kukin reuna on oikeiden kvadranttien välissä seuraavasti:
\begin{itemize}[label={}]
  \item kun $Q(u) = \mathsf{N}$ niin $Q(\mathsf{W}(u)) = \mathsf{NE}$ ja $Q(\mathsf{E}(u)) = \mathsf{NW}$,
  \item kun $Q(u) = \mathsf{E}$ niin $Q(\mathsf{N}(u)) = \mathsf{SE}$ ja $Q(\mathsf{S}(u)) = \mathsf{NE}$,
  \item kun $Q(u) = \mathsf{S}$ niin $Q(\mathsf{W}(u)) = \mathsf{SE}$ ja $Q(\mathsf{E}(u)) = \mathsf{SW}$, sekä
  \item kun $Q(u) = \mathsf{W}$ niin $Q(\mathsf{N}(u)) = \mathsf{SW}$ ja $Q(\mathsf{S}(u)) = \mathsf{NW}$.
\end{itemize}

Haluamme myös että kullekin ankkurille $v$ pätevät seuraavat ehdot: $Q(\mathsf{N}(v) = S$,$Q(\mathsf{NE}(v) = SW$, $Q(\mathsf{E}(v) = W$, $Q(\mathsf{SE}(v) = NW$, $Q(\mathsf{S}(v) = N$, $Q(\mathsf{SW}(v) = NE$, $Q(\mathsf{W}(v) = E$, ja $Q(\mathsf{NW}(v) = SE$.

$P_2$ edellyttää myös, että kukin diagonaalien muodostama polku on 2-väritetty värityksellä $x(v) \in \{0, 1\}$ siten, että jos $Q(v) = Q(diag(v))$, $x(v) \neq x(diag(v))$. 2-värittämällä samantyyppiset solmut varmistamme, että yhtä solmutyyppiä esiintyy vain pieniä alueita alle lineaariaikaisissa ratkaisuissa: rajaamattoman kokoisen alueen 2-värittäminen vaatisi $\Omega(n)$ kommunikaatiokierrosta.

$P_2$:n oikeellisen ratkaisun on tulostettava $M$:n suoritustaulu kustakin ankkurista alkaen. Ajatellaan ankkuria $v$ koordinaatiston nollakohtana eli $v = (0, 0)$. Kun $M$ pysähtyy $s$ askeleen jälkeen tyhjällä nauhalla käynnistyttyään, sen suoritustaulun $E(M)$ voi koodata $r \times (s+1)$ -kokoiseen alihilaan, missä $r \leq s + 1$. Alihilan vasen alakulma on $v$. Tämän alihilan $x$-akseli kuvaa $M$:n nauhan solua ja $y$-akseli aikaa: solmussa $(i, j)$ on siis nauhan $i.$ solu ajan hetkellä $j$. Lisäksi kullakin $y$-akselin rivillä yhteen soluun on merkitty $M$:n luku-kirjoituspää ja tila. Kun $y = 0$, eli ennen $M$:n suorituksen aloittamista, luku-kirjoituspää on ankkurissa $v$. $y$-akselin rivien välillä näkee $M$:n suorituksen etenemisen askel askeleelta.
\begin{figure}
  \centering
  \includegraphics{p2_hila.png}
  \caption{Esimerkki $P_2$:n ankkurista $\mathsf{A}$ ja sen lähiympäristöstä. Kukin muu solmu kertoo, mihin suuntaan hilassa on siirryttävä löytääkseen ankkurin. Solmun väritys kuvaa 2-väritystä, joka pätee samantyyppisten solmujen välillä. $E(M)$ koodataan ankkuriin ja siitä alkaen $\mathsf{S}$, $\mathsf{W}$ ja $\mathsf{SW}$ -tyyppisiin solmuihin.}
\end{figure}

Oikeellinen $L_M$:n ratkaisu on joko $P_1$:n tai $P_2$:n. $P_1$:n, riittää kunkin solmun tarkastaa että milläkään sen naapurilla ei ole samanväristä naapuria. $P_1$:n ratkaisu on siis selvästi paikallisesti tarkastettavissa. $P_2$:n kukin solmu voi selvästi tarkistaa, sopiiko sen tyyppi sen välittömiin naapureihin ja diagonaalinsa 2-väritykseen. Hilaan koodatun $E(M)$:n oikeellisuus on helppo tarkastaa paikallisesti $M$:n määritelmän perusteella: kukin $2 \times 2$ -ruutu hilasta voi tarkistaa onko sen ylempi rivi oikeellinen alemman rivin ja $M$:n tilasiirtymätaulun mukaisesti. Kukin $\mathsf{W}$-tyyppinen solmu voi tarkistaa nauhan olevan tyhjä $M$:n suorituksen aluksi. $E(M)$:n yläreunan solmut voivat tarkastaa $O(s)$ kierroksessa päättyykö suoritus $M$:n lopputilaan.

\subsubsection{$L_M$:n ratkaiseminen}
Brandt ym.~\cite{brandt} osoittavat, että kun $M$ pysähtyy, $L_M$ on ratkaistavissa $O(\log^* n)$ kommunikaatiokierroksella. Oletetaan, että $M$ pysähtyy $s$ askeleen jälkeen, missä $s$ riippuu vain $M$:stä. Jos $n < 2(s + 1)$, voidaan $P_1$ ratkaista vakioajassa käymällä koko verkko läpi. Muussa tapauksessa aloitetaan ratkaisun etsiminen $P_2$:en.

Ratkaisun etsiminen aloitetaan etsimällä maksimaalinen riippumaton joukko $I$ verkosta $G^{(4(s+1))}$. Kukin $I$:n solmu asetetaan ankkuriksi. Muodostetaan kunkin $v \in I$ ympärille Voronoi-laatta $T(v)$ joka sisältää kaikki solmut jotka ovat lähempänä $v$:tä kuin mitään muuta ankkuria. Kahden tai useamman ankkurin ollessa yhtä lähellä valitaan solmulle laatta mielivaltaisesti mutta konsistentisti. Koska kunkin ankkurin etäisyys toisistaan on rajattu $s$:n perusteella, myös kunkin laatan koolla on yläraja joka riippuu vain $M$:stä.

Kunkin ankkurin $v = (x, y)$ ympäristö merkitään tyypeillä vastaten kunkin solmun sijaintia ankkurin suhteen:
\[
 Q(u) = 
  \begin{cases} 
   \mathsf{N} & \text{kun } x_u = x \text{ ja } y_u < y, \\
   \mathsf{NE} & \text{kun } x_u < x \text{ ja } y_u < y, \\
   \mathsf{E} & \text{kun } x_u < x \text{ ja } y_u = y, \\
   \mathsf{SE} & \text{kun } x_u < x \text{ ja } y_u > y, \\
   \mathsf{S} & \text{kun } x_u = x \text{ ja } y_u > y, \\
   \mathsf{SW} & \text{kun } x_u > x \text{ ja } y_u > y, \\
   \mathsf{W} & \text{kun } x_u > x \text{ ja } y_u = y, \\
   \mathsf{NW} & \text{kun } x_u > x \text{ ja } y_u < y. \\
  \end{cases}
\]
Tyyppien määrittelyn yhteydessä solmuille voi määritellä myös tarvittavan 2-värityksen. $M$:n suoritustaulun kirjoittaminen hilaan aloitetaan kustakin ankkurista ja jatketaan kunnes $M$ pysähtyy $s$ askeleen päästä. $I$:n muodostaminen vaatii $O(\log^* n)$ kommunikaatiokierrosta, mutta muut edellä kuvatut toimenpiteet vaativat $s$:n mukaan rajatun määrän kommunikaatiokierroksia. Kun $M$ on kiinnitetty, $s$ on vakio, joten $L_M$:n ratkaisu on löydettävissä $O(\log^* n)$-ajassa.

Koska $P_1$ on ratkaistavissa $O(n)$ kommunikaatiokierroksessa, $L_M$:ään on varmasti olemassa $O(n)$ kommunikaatiokierroksessa ratkaisun löytävä algoritmi. Osoitamme seuraavaksi, että tämä on ratkaisun löytämiseksi myös alaraja, jos $M$ ei pysähdy. Tämän vuoksi joudumme varmistamaan ettei $P_2$:n ratkaisu löyty nopeammin.

Eräs mahdollinen ratkaisu $P_2$:en ilman $M$:n suoritustaulun kirjoittamista on jättää ankkurit pois ja merkitä kukin solmu kuulumaan samaan kvadranttiin. Tällöin kunkin solmun arvo on sama joukosta $\{\mathsf{NE}, \mathsf{SE},\mathsf{SW},\mathsf{NW}\}$. Koska $P_2$ edellyttää samantyyppisien diagonaalinaapurien 2-väritystä, ja diagonaalinaapurien muodostamien polkujen pituus on $\Omega(n)$, selvästi tämän ratkaisutavan vaativuus on myös $\Omega(n)$.

$P_2$:n ratkaisussa voi olla kvadranttien lisäksi yksi tai useampi diagonaali, joka koostuu jostakin joukon $\{\mathsf{N}, \mathsf{E},\mathsf{S},\mathsf{W}\}$ tyypistä. Tämän diagonaalin on kierrettävä koko hilan ympäri tai törmättävä ankkuriin. Jos diagonaali kiertää koko hilan ympäri, $P_2$:n ratkaisevan algoritmin on jälleen käytettävä väistämättä $\Omega(n)$ kommunikaatiokierrosta löytääkseen tälle diagonaalille 2-väritys.

Jos $P_2$:a ratkaiseva algoritmi luo ratkaisuun ankkurin, sen on myös aloitettava $M$:n suoritustaulun kirjoittaminen ollakseen oikeellinen. Koska $M$ ei pysähdy äärellisessä ajassa, $E(M)$:n kirjoittaminen katkeaa vain jos algoritmi kirjoittaa virhellisen siirtymän, mikä tekee ratkaisusta virheellisen. $E(M)$:n kirjoittaminen jatkuu muussa tapauksessa hilan ympäri jolloin se jatkuu solmuun, jonka tyyppi on $\mathsf{N}$ tai $\mathsf{NW}$. Tällöin ratkaisu ei ole oikeellinen.

Koska $P_1$ vaatii aina $\Omega(n)$ kommunikaatiokierrosta ja $P_2$:n oikeellinen ratkaisu vaatii $\Omega(n)$ kommunikaatiokierrosta jos $M$ ei pysähdy tyhjällä nauhalla, $L_M$:än ratkaiseminen kaikkiaan vaatii $\Omega(n)$ kommunikaatiokierrosta jos $M$ ei pysähdy tyhjällä nauhalla. Muussa tapauksessa $P_2$:n ja siten $L_M$:n voi ratkaista $O(\log^* n)$ kommunikaatiokierroksessa. Koska mielivaltaisen Turingin koneen $M$ pysähtymisen määrittäminen on Turing-ratkeamaton ongelma, on sitä vastaavan $L_M$:n aikavaativuuden määrittäminen yhtä lailla ratkeamaton. Yleisemmin voimme todeta että on ratkeamaton ongelma selvittää, onko annetulle \lcl -ongelmalle olemassa $O(\log^* n)$-ajassa toimiva ratkaisualgoritmi.

\section{Algoritmin synteesi}
Vaikka \lcl -ongelman aikavaativuuden määrittäminen yleisessä tapauksessa on edellisen teoreeman mukaisesti ratkeamaton ongelma, on mahdollista muodostaa asymptoottisesti optimaalinen algoritmi \lcl -ongelmalle jonka aikavaativuuden jo tiedämme. Brandt ym.~\cite{brandt} esittelevät menetelmän, jolla voi muodostaa $O(\log^* n)$ -aikaisen algoritmin ongelmalle jonka tiedetään ratkeavan $O(\log^* n)$ -ajassa.

Olkoon $P$ \lcl -ongelma, ja $p \in {0, 1}$ on bitti joka saa arvon 1 jos ja vain jos $P$:lle on olemassa $O(\log^* n)$-aikainen ratkaisualgoritmi. Jos $b = 0$, nopeutuslemman mukaisesti $P$:n ratkaisemiseen tarvitaan $\Omega(n)$ kommunikaatiokierrosta. Tällöin asymptoottisesti optimaalinen algoritmi on kerätä koko verkon rakenne kuhunkin solmuun ja antaa kunkin solmun ratkaista ongelma sisäisesti. Jos $b = 1$, ongelman voi ratkaista $O(1)$ kommunikaatiokierroksessa jos ja vain jos on olemassa vakiotuloste jonka voi laittaa jokaiseen verkon solmuun.
%TODO todista ylläoleva jossain aiemmin. Tee siitä oma lemmansa

%TODO V "Ainoa vaativampi tapaus" -- onhan se O(n) kans aika vaativa?
Ainoa vaativampi tapaus on siis ongelma, jonka optimaalinen ratkaisu vaatii $\Theta(\log^* n)$ kommunikaatiokierrosta. Nopeutuslemmaa käyttäen tiedämme, että jos \lcl -ongelmalle on olemassa algoritmi $A$ jonka aikavaativuus on $o(n)$, sen perusteella voidaan muodostaa uusi algoritmi $A' \circ S_k$ jollekin vakiolle $k$ siten, että $S_k$ muodostaa ankkurien joukon $I$ joka on maksimaalinen riippumaton joukko $G^k$:ssa, ja $A'$ on $O(k)$ kommunikaatiokierroksessa toimiva algoritmi joka ottaa syötteenään ankkurijoukon $I$ ja ratkaisee sen jälkeen ongelman nopeutuslemman esittelemään tapaan.

%TODO tarkasta ylläoleva

\begin{figure}
  \includegraphics[width = 300pt]{synteesi.png}
  \caption{Algoritmin synteesi esiteltynä prosessikaaviona. Harmaalla merkityt työvaiheet eivät ole ongelmakohtaisia, vaan ne tarvitsee suorittaa vain kerran kullekin $k$. Ongelmien esikarsinta tarvitsee suorittaa kaikkiaan vain kerran.}
\end{figure}

Voimme ajatella nopeutuslemman käyttämää prosessia tässä yksinkertaisemmin algoritmina, joka ottaa syötteekseen ankkurien sijainnit $O(k)$-säteisessä naapurustossa ja tuottaa niiden perusteella tulosteen. Nopeutuslemman tuottama algoritmi $A'$ voidaan siis nähdä äärellisenä funktiona $O(k)$-säteisistä naapurustoista, jotka on merkitty joukosta $\{0, 1\}$ kuvaamaan ankkurien sijainteja, $A'$:n lopullisiin, paikallisiin tulosteisiin.

Naapuruston säteen $k$ voi etsiä iteratiivisesti aloittamalla arvosta $k = 1$ ja kasvattamalla $k$:ta kunnes $O(\log^* n)$-aikaisen algoritmin synteesi onnistuu. Jos $P$:n aikavaativuus on $\Omega(n)$, mikään $k$:n arvo ei tuota toimivaa algoritmia joten $k$:n kasvattaminen ei pääty ikinä. Kullekin $k$:n arvolle valitaan $r_1, r_2 \in \Theta(k)$ ja muodostetaan kaikki erilaiset $r_1 \times r_2$ -kokoiset ruudut ankkureineen. $r_1$ ja $r_2$ on valittava tarpeeksi suuriksi siten, että kaikki ankkurien joukon eri konfiguraatiot tulevat esiin.
%TODO selvennä ylläolevaa

Brandt ym.~\cite{brandt} esittelevät menetelmän, joka tuottaa kaikki $a \times b$ -kokoiset ruudut, jotka voivat esiintyä ankkurien joukossa. Kun $G$ on verkko ja $I \subset V(G)$ on maksimaalinen riippumaton joukko $G$:ssä, voidaan paria $(G', I')$ kutsua parin $(G, I)$ ruuduksi kun $G'$ on $G$:n indusoitu aliverkko ja $I' = V(G') \cap I$. Voimme siis ajatella ruudun sisältävän palan koko verkosta ja sen maksimaalisesta riippumattomasta joukosta.
%TODO tarkista onko indusoitu aliverkko määritelty

Joukon $V' \subseteq V(G)$ naapurusto $G$:ssä määritellään $B_G(V', 1) = \bigcup_{v \in V'} B_G(v, 1)$. Löytääksemme $a \times b$ -kokoisia ruutuja, tarkastelemme ruutua $(G'', I'')$ jonka ulottuvuudet ovat $a \times b$ ja yritämme muodostaa suuremman ruudun $(G', I')$ sen pohjalta. Erityisesti haluamme, että on olemassa $I'$ siten että $(G', I')$ voi olla maksimaalisen riippumattoman joukon $I$ osana.

Olkoon $V_d = (V(G') \ V(G'')) \ B_G(I'', 1)$. Koska yksikään $V_d$:n solmu ei ole $I''$:n vieressä, voi kukin sen solmu kuulua $I''$:n kanssa samaan riippumattomaan joukkoon. Kaikille riippumattomille joukoille $I_d = V_d$ haluamme tutkia muodostaako $(G', I_d \cup I'')$ ruudun joka voi esiintyä $(G, I)$:ssä.

Ruudun voi tarkistaa muodostamalla joukon $V_u = V(G') \ B_G(I_d \cup I'', 1)$. Jos $V_u = \emptyset$, on $(G', I_d \cup I'')$ mahdollinen ruutu $(G, I)$:ssä.
%TODO todista

Jos $V_u \neq \emptyset$, sisältää ruutu $(G', I_d \cup I'')$ solmuja jotka eivät kuulu maksimaaliseen riippumattomaan joukkoon tai ole sen naapurissa. Tällaisilla solmuilla täytyy kullakin voida olla vähintään yksi naapuri joukossa $I \setminus G'$ jotta $(G', I_d \cup I'')$ olisi oikeellinen ruutu. Formaalimmin, jos ruutu on oikeellinen, on oltava olemassa riippumaton joukko $I_n \in (V(G) \ G(G')) \ B_G(I_d \cup I'', 1)$ siten että $V_u \in B_G(I_n)$.
%TODO ylläolevan kappaleen setminus lisättiin jälkikäteen. Mieti onko se varmasti oikein

Riippumattoman joukon $I_n$ etsinnän voi esittää verkon peiteongelmana. Muodostetaan joukko $S_v = (B_G(v, 1) \ V(G')) \ B_G(I'' \cup I_d, 1))$ kullekin $v \in V_u$. Oikeellinen $I_n$ on riippumaton joukko jolla $I_n \cap S_v \neq \emptyset$ kaikille $v$, ja sen etsimisen voi toteuttaa SAT-ratkaisimella.

Muodostetaan naapurustoverkko $H = (V_H, E_H)$ missä $V_H$ on kaikkien $r_1 \times r_2$ -kokoisten ruutujen joukko, ja kukin $e \in E_H$ on $(r_1 + 1) \times r_2$ tai $r_1 + (r_2 + 1)$ -kokoinen ruutu. Kun $u, v in V_H$, $(u, v) \in E_H$ jos ja vain jos $v$:n voi sijoittaa $u$:n yläpuolelle tai oikealle puolelle tuottaen ruudun $e \in E_H$. Jos $e$:n koko on $(r_1 + 1) \times r_2$, $\ell(e) = \mathsf{E}$, muuten $\ell(e) = \mathsf{N}$. 

Nyt $H$ on verkko joka kuvaa mahdollisia tapoja sijoittaa ankkurit, ja $A'$ on kuvaus $V_H$:sta paikallisiin tulosteisiin siten, että $A'(v)$ on tuloste solmulle jonka naapuruston ankkurit $I$:ssä vastaavat $v$:tä. Haluamme muodostaa $A'$:n siten, että kullekin $V_H$ muodostettu tulostearvo sopii $I$:n kaariin; jos $(u, v) \in E_H$ joillekin $u, v \in V_H$, haluamme että $A'(u)$ ja $A'(v)$ sopivat $P$:n vaatimuksiin.

Sopivan $A'(v): V_H \rightarrow \Gamma$ etsimisen voi esittää SAT-ongelmana, ja jättää varsinaisen ongelman ratkaisemisen SAT-ongelmien ratkaisemiseen erikoistuneelle algoritmille. Jos ratkaisua ei ole, kasvatetaan $k$:ta kunnes ratkaiseva algoritmi löytyy. Kuten aiemmin todettiin, $k$:ta voi kasvattaa mielivaltaisen suureksi löytämättä ratkaisua jos $P$:n ratkaisu vaatii $\Omega(n)$ kommunikaatiokierrosta.

Brandt ym.~\cite{brandt} toteavat, että vaikka $r_1 \times r_2$ -kokoisten ankkuriruutujen lukumäärä voi vaikuttaa kasvavan hyvin suureksi $k$:n kasvaessa, käytännössä käsiteltävien ruutujen määrä on hyvin maltillinen. Tämä johtuu siitä, että ankkurit ovat maksimaalinen riippumaton joukko $G^k$:ssa joten niitä on harvemmassa ja harvemmassa $k$:n kasvaessa.

\subsection{Esimerkki algoritmin syntetisoimisesta}
Olkoon $P$ verkon 4-väritysongelma. $P$:n ratkaisu on oikeellinen kun kullekin verkon solmulle on määritetty yksi neljästä väristä siten että kunkin solmun $v$ kaikki naapurit ovat erivärisiä kuin $v$ itse. Tällainen väritys on olemassa kaikille tarpeeksi isoille hiloille.

Olkoon $k = 1, r_1 = 2$ ja $r_2 = 3$. Olkoon $I$ maksimaalinen riippumaton joukko verkossa $G^k$. Tällöin $G$:n $r_1 \times r_2$ -kokoisissa ruuduissa voi esiintyä ankkureita seuraavanlaisesti:
\begin{center}
\begin{tabular}{ | c | }
  \hline
  00 \\
  00 \\
  10 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  00 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  00 \\
  10 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  00 \\
  01 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  10 \\
  00 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  01 \\
  00 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  00 \\
  01 \\
  10 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  10 \\
  00 \\
  10 \\
  \hline
\end{tabular}
\\
\begin{tabular}{ | c | }
  \hline
  01 \\
  00 \\
  10 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  00 \\
  10 \\
  01 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  10 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  01 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  01 \\
  10 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  10 \\
  01 \\
  00 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  01 \\
  10 \\
  01 \\
  \hline
\end{tabular}
\begin{tabular}{ | c | }
  \hline
  10 \\
  01 \\
  10 \\
  \hline
\end{tabular}
\end{center}
%TODO allaoleva sisältää tavaraa joka ei kuulu esimerkkiin.
Ajatellaan näitä ruutuja omana verkkonaan $H = (V_H, E_H)$. Ruudut muodostavat solmujen joukon $V_H$. Muodostetaan lisäksi kaarten joukko $E_H$ siten että kunkin kahden solmun välillä on kaari jos niistä voi muodostaa uuden laatan joka on ulottuvuuksiltaan $(r_1 + 1) \times r_2$ tai $r_1 \times (r_2 + 1)$ siten, että uusi laatta voi edelleen esiintyä $G^k$:n maksimaalisssa riippumattomassa joukossa. Esimerkiksi laatan
\begin{center}
\begin{tabular}{ | c | }
  \hline
  001 \\
  100 \\
  001 \\
  \hline
\end{tabular}
\end{center}
voi muodostaa yhdistämällä laatat
\begin{center}
\begin{tabular}{ | c | }
  \hline
  00 \\
  10 \\
  00 \\
  \hline
\end{tabular}
~ja~ 
\begin{tabular}{ | c | }
  \hline
  01 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\end{center}
eli $E_H$:ssa on suunnattu kaari
\Bigg(
\begin{tabular}{ | c | }
  \hline
  00 \\
  10 \\
  00 \\
  \hline
\end{tabular}
,
\begin{tabular}{ | c | }
  \hline
  01 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\Bigg). Vastaavasti esimerkiksi laatat
\begin{center}
\begin{tabular}{| c |}
 \hline
 00 \\
 01 \\
 10 \\
 \hline
\end{tabular}
~ja~
\begin{tabular}{| c |}
 \hline
 10 \\
 00 \\
 01 \\
 \hline
\end{tabular}
\end{center}
voivat muodostaa $2 \times 4$ -kokoisen laatan
\begin{tabular}{| c |}
\hline
10 \\
00 \\
01 \\
10 \\
\hline
\end{tabular}
joten $E_H$:ssa on sitä vastaava suunnattu kaari \Bigg(
\begin{tabular}{ | c | }
  \hline
  00 \\
  01 \\
  10 \\
  \hline
\end{tabular}
,
\begin{tabular}{ | c | }
  \hline
  10 \\
  00 \\
  01 \\
  \hline
\end{tabular}
\Bigg) jonka kaarimerkintä on $\mathcal{N}$. Kuitenkaan emme voi muodostaa kaarta ruutujen
\begin{center}
\begin{tabular}{| c |}
 \hline
 10 \\
 00 \\
 10 \\
 \hline
\end{tabular}
~ja~
\begin{tabular}{| c |}
 \hline
 01 \\
 00 \\
 01 \\
 \hline
\end{tabular}
\end{center}
välille, sillä näin syntyvä laatta
\begin{tabular}{| c |}
 \hline
 101 \\
 000 \\
 101 \\
 \hline
\end{tabular}
ei voi olla osa maksimaalista riippumatonta joukko $G^k$:ssä.

Kutsutaan näin syntyvää verkkoa \textit{pseudohilaksi}, sillä sillä on samanlaisia ominaisuuksia kuin hilalla. Kullakin solmulla on pohjois-, itä-, etelä- ja länsinaapurit, ja niiden suhteet ovat käänteiset samoin kuten normaalilla hilalla; jos $u$ on solmun $v$ pohjoisnaapuri, niin vastaavasti solmun $v$ on oltava solmun $u$ etelänaapuri.

Toisin kuin tavallisessa hilassa, pseudohilan kullakin solmulla voi olla kussakin ilmansuunnassa useampi kuin yksi naapuri. Haluamme määrittää tulosarvon $H$ kullekin solmulle siten, että jos $(u, v) \in E_H$ niin $c(u) \neq c(v)$ väritysongelman ehtojen mukaisesti. Koska kyseessä on 4-väritys, haluamme myös että $c(v) \in \{1, 2, 3, 4\}$ kaikille $v \in V_H$.

Tämän värityksen etsimisen voimme ulkoistaa valmiille SAT-ratkaisimelle. Tätä varten ongelma on muotoiltava konjunktiiviseen normaalimuotoon (jatkossa CNF, \textit{conjunctive normal form}), jota SAT-ratkaisijat käyttävät. CNF-lause on konjunktioilla yhdistetty joukko lausekkeita, jotka koostuvat yhdestä tai useammasta disjunktiolla yhdistetystä muuttujasta tai muuttujan negaatiosta.

\section{Paikallisten ongelmien etsiminen}
Algoritmisynteesi tarjoaa oivallisen työkalun $O(\log^* n)$ -aikaisten ongelmien etsimiseen. Vaikka paikallisten ja globaalien ongelmien joukot ovat rekursiivisesti erottamattomia, on mahdollista tunnistaa lukuisia paikallisia ongelmia yrittämällä algoritmisynteesiä tarpeeksi suurella $k$ tarpeeksi suurelle joukolle ongelmia.

%TODO tarkista että olet todistanut aikavaativuuden rekursiivisen erottamattomuuden

Tarkastellaan \lcl -ongelmia, joiden tarkastussäde $r = 1$, syötemerkkien joukko $\Sigma = \emptyset$ ja tulostemerkkien joukko $\Gamma = \{0, 1\}$. Kutsun näitä ongelmia binäärisiksi ongelmiksi, ja osoitan algoritmisynteesin kautta lukuisien niistä kuuluvan $O(\log^* n)$ -aikavaativuusluokkaan.

Binääriset \lcl -ongelmat eroavat toisistaan sallittujen osaratkaisujensa osalta. Kukin osaratkaisu on 1-säteinen naapurusto hilassa, joten kukin osaratkaisu on esitettävissä viidellä bitillä: yksi kuvaamaan osaratkaisun keskipistettä ja yksi kullekin keskellä olevan solmun naapurille. Näin ollen osaratkaisuja on $2^5 = 32$ erilaista. Merkitsemme jatkossa osaratkaisuja viiden bitin jonoilla joissa ensimmäinen bitti kuvaa naapuruston keskibittiä ja seuraavat neljä järjestyksessä pohjois-, itä-, etelä- ja länsinaapuria; esimerkiksi $01011$ kuvaa naapurustoa jonka keskellä on nolla ja itäpuolella nolla, pohjois-, etelä- ja länsipuolella ykkönen.

Kun osaratkaisuja on $32$, niistä voi muodostaa yhteensä $2^{32}$ eri \lcl -ongelmaa, eli yli neljä miljardia. On laskennallisesti epämielekästä yrittää algoritmisynteesiä näin monelle eri ongelmalle. Esittelen seuraavaksi joitakin yksinkertaisia optimointeja, jotka vähentävät tarkasteltavien ongelmien määrää.

\subsection{Ylijoukkojen eliminointi}
Olkoot $A$ ja $B$ \lcl -ongelmia ja $\mathcal{C}_A$ ja $\mathcal{C}_B$  niiden sallittujen osaratkaisujen joukot. Jos $\mathcal{C}_A \subseteq \mathcal{C}_B$, $B \in O(log^* n)$ jos $A \in O(log^* n)$.

$A$:n sallittujen osaratkaisujen ollessa $B$:n osaratkaisujen osajoukko ei $B$ voi olla missään tilanteessa $A$:ta vaikeampi ongelma, sillä $A$:n ratkaiseva algoritmi tuottaa samalla oikeellisen ratkaisun myös $B$:hen. Näin ollen meidän ei tarvitse yrittää algoritmisynteesiä \lcl -ongelmille, joiden jollekin osajoukolle tiedetään jo olevan olemassa $O(log^* n)$-aikainen algoritmi.

Merkittävä erikoistapaus ovat triviaalit ongelmat, jotka ovat tarkalleen ne, joiden sallittujen osaratkaisujen joukossa esiintyy joko pelkkää ykköstä tai pelkkää nollaa sisältävä ruutu. Nämä ongelmat eliminoimalla meille jää tarkasteltavaksi vain $2^{30}$ \lcl -ongelmaa.

\subsection{Osittaissymmetrian eliminointi}
Jäljelle jäävät viisibittiset osaratkaisut voidaan jakaa kahteen ryhmään sen mukaan, onko niiden keskipisteessä olevan solmun arvo $1$ vai $0$. On selvää, että vaihtamalla ongelman kaikkien osaratkaisuiden ykköset nolliksi ja nollat ykkösiksi ongelman luonne ja vaikeus eivät muutu. Tämän vuoksi emme tarkastele ollenkaan ongelmia, joiden kaikkien osaratkaisuiden keskimmäisen solmun arvona on $1$ --- niiden aikavaativuus on identtinen vastaavan ongelman, jossa jokainen bitti on käännetty, kanssa.

Voimme laajentaa edellä mainittua optimointia myös ongelmiin, joissa osaratkaisut joiden keskellä on $1$ ovat käännettynä osajoukko saman ongelman osaratkaisuista joiden keskellä on $0$. Tällöin poistamme tarkastelusta $3^{15}$ ongelmaa.
%TODO matemaattinen perustelu ylle

\subsection{Synteesin automatisoiminen}
$O(\log^* n)$ -aikaisten \lcl -ongelmien etsimisen automatisointi on monivaiheinen prosessi. Kullekin $k$ jolle synteesiä halutaan yrittää tarvitaan pseudohila, jossa kukin solmu kuvaa yhtä mahdollista ruutua verkon $G^k$ maksimaalisille riippumattomille joukoille. Kun pseudohila on luotu, sitä ei tarvitse luoda erikseen joka ongelmaa varten vaan samaa pseudohilaa voi käyttää kaikille \lcl -ongelmille. Uusi pseudohila tarvitaan, jos halutaan kokeilla ratkaisemista toisella $k$:n arvolla.

%TODO määrittele pseudohila jossain, se on hieno termi

Pseudohila ja \lcl -ongelma halutaan muuttaa ratkaisua varten CNFSAT-muotoon. Koska \lcl -ongelmalle ei ole intuitiivista esitysmuotoa CNFSAT-muodossa, käytetään väliasteena normaalia propositiologiikkaa.

Olkoon \lcl -ongelma $L = (r, \Sigma, \Gamma, \mathcal{C})$ ja pseudohila $G = (V, E)$. Määritellään lisäksi $f_\Gamma : \rightarrow \{ 0, 1, \ldots, |\Gamma|-1\}$, $f_\mathcal{C} : \mathcal{C} \rightarrow \{1, 2, \ldots, |\mathcal{C}|\}$ ja $f_V : V \rightarrow \{1, 2, \ldots, |V|\}$  numeroinneiksi tulostusmerkeille, solmuille ja naapurustoille.

Kun $|\Gamma| \cdot f_V(v) + f_\Gamma(s) = n$, kuvatkoon muuttuja $x_n$ väitettä "solmu $v$ tulostaa arvon $s$". Koska kullakin solmulla täytyy olla tarkalleen yksi tuloste, vaadimme seuraavien ehtojen täyttymistä:
%TODO tarkista off by ponet, katso onko "solmu v saa arvon c" notaation piirissä
$$(x_n \vee x_{n+1} \vee x_{n+2} \vee \ldots \vee x_{n+|\Gamma|-1})$$

kun $n = f_V(v)$ jollekin $v \in V$, ja 

$$\lnot(x_m \land x_p)$$

kaikille $m < p$ kun $m = |\Gamma| \cdot f_V(v) + f_\Gamma(s)$ ja $p = |\Gamma| \cdot f_V(v) + f_\Gamma(s')$ kun $v \in V$ ja $s, s' \in \Gamma$.

Nyt kullekin $v \in V$ voi olla vain tarkalleen yksi tuloste $s \in \Gamma$. Haluamme kuitenkin edellyttää myös, että jokaisen solmun naapurusto on jokin sallittu ratkaisu. Kun $|\mathcal{C}| \cdot f_V(v) + f_\mathcal{C}(c) = n$, kuvatkoon muuttuja $t_n$ väitettä "$B_G(v, 1)$ on isomorfinen naapuruston $c$ kanssa". Toisin sanoen jokainen $t_n$ kuvaa tietyn solmun $v$ naapuruston olevan tietty sallittu naapurusto.

%TODO ehkä esimerkki?

Kun $n = f_V(v)$ jollekin $v \in V$, kuvatkoon muuttuja $d_n$ väitettä "solmun $v$ naapurusto on jokin ongelman $L$ sallituista ratkaisuista". Propositiologiikan kielellä ilmaistuna
$$d_n = \bigwedge_{i = {|\mathcal{C}| \cdot n}}^{|\mathcal{C}| \cdot (n+1) - 1} t_i$$.

Nämä propositiologiikan lauseet määrittelevät kokonaan \lcl -ongelman $L$ käytetylle pseudohilalle. Määrittelemme vielä lopullisen ehdon

$$(d_1 \land d_2 \land \ldots \land d_{|V|})$$

jonka täyttyessä \lcl -ongelmaan $L$ on olemassa ratkaisu. \lcl -ongelmalle $L$ luodaan automaattisesti pseudohilan ja ongelman määrittelyn perusteella yllä esitellyt loogiset lauseet circuit-muotoon koodattuna.
%TODO ^lähde circuitille
%TODO tarkista kaavan ylä- ja alaindeksi

Circuit-muodossa oleva ongelma käännetään konjunktiiviseen normaalimuotoon (CNFSAT) jotta se voidaan ratkaista normaalilla SAT-ratkaisimella (esimerkiksi MINISAT). Ratkaisun löytyessä siitä voidaan johtaa $L$:n ratkaisu jota voidaan käyttää $O(\log^* n)$ -aikaisen ratkaisualgoritmin tuottamiseen.


\section{Päätelmät}






% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\bibliographystyle{babplain-lf}
\bibliography{lahteet}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}

